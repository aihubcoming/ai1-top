var d=Object.defineProperty;var T=(i,e,a)=>e in i?d(i,e,{enumerable:!0,configurable:!0,writable:!0,value:a}):i[e]=a;var h=(i,e,a)=>T(i,typeof e!="symbol"?e+"":e,a);import{g as p,w as g,a as A}from"./index-1aj0ASgY.js";class w{constructor(){h(this,"accountsCache",new Map);h(this,"CACHE_TTL",24*60*60*1e3);h(this,"marketsCache",{});h(this,"MARKETS_CACHE_TTL",60*60*1e3)}createAccountKey(e,a){return`${e}:${a}`}createMarketsCacheKey(e,a,t){return`${e}:${a?"sandbox":"live"}:${t}`}isInstanceValid(e){return Date.now()-e.lastAccess<this.CACHE_TTL}isMarketsValid(e){const a=this.marketsCache[e];return a?Date.now()-a.timestamp<this.MARKETS_CACHE_TTL:!1}async loadMarketsWithCache(e,a,t,c){const s=this.createMarketsCacheKey(a,t,c);if(this.isMarketsValid(s)){console.log(`ðŸ“‹ [CCXTAccountManager] Using cached markets for ${s}`),e.markets=this.marketsCache[s].markets;return}console.log(`ðŸ”„ [CCXTAccountManager] Loading fresh markets for ${s}`),await e.loadMarkets(),this.marketsCache[s]={markets:e.markets,timestamp:Date.now()},console.log(`âœ… [CCXTAccountManager] Cached markets for ${s}`)}async getRegularInstance(e,a="spot"){const t=this.createAccountKey(e.accountId,e.exchange);this.accountsCache.has(t)||this.accountsCache.set(t,{regular:new Map});const c=this.accountsCache.get(t),s=c.regular.get(a);if(s&&this.isInstanceValid(s))return s.lastAccess=Date.now(),console.log(`ðŸ“‹ [CCXTAccountManager] Using cached regular instance: ${t}:${a}`),s.instance;console.log(`ðŸ”„ [CCXTAccountManager] Creating new regular instance: ${t}:${a}`);const o=p();if(!o)throw new Error("CCXT not available");const r=o[e.exchange];if(!r)throw new Error(`Exchange ${e.exchange} not found in CCXT`);let l=a;e.exchange==="bybit"&&(l={spot:"spot",futures:"linear",swap:"linear",margin:"spot",options:"option"}[a]||a,console.log(`ðŸ” [CCXTAccountManager] Bybit mapping: ${a} -> ${l}`));const n={sandbox:e.sandbox,apiKey:e.apiKey,secret:e.secret,password:e.password,enableRateLimit:!0,defaultType:l};console.log(`ðŸ” [CCXTAccountManager] Creating ${e.exchange} regular instance:`,{accountId:e.accountId,sandbox:n.sandbox,apiKey:n.apiKey?"SET":"NOT_SET",secret:n.secret?"SET":"NOT_SET",defaultType:n.defaultType,marketType:a});const C=new r(n),u=g(C,e.exchange,e.accountId);return await this.loadMarketsWithCache(u,e.exchange,e.sandbox,a),c.regular.set(a,{instance:u,lastAccess:Date.now(),marketsLoaded:!0}),console.log(`âœ… [CCXTAccountManager] Cached regular instance: ${t}:${a}`),u}async getProInstance(e){console.log(`ðŸ“¡ [CCXTAccountManager] Getting CCXT Pro instance for ${e.accountId}:${e.exchange}`);const a=A();if(!a)return console.warn("âš ï¸ [CCXTAccountManager] CCXT Pro not available"),null;const t=this.createAccountKey(e.accountId,e.exchange);this.accountsCache.has(t)||this.accountsCache.set(t,{regular:new Map});const c=this.accountsCache.get(t),s=Date.now();if(c.pro&&this.isInstanceValid(c.pro))return c.pro.lastAccess=s,console.log(`ðŸ“‹ [CCXTAccountManager] Using cached CCXT Pro instance for ${t}`),c.pro.instance;console.log(`ðŸ”„ [CCXTAccountManager] Creating new CCXT Pro instance for ${t}`);try{const o=a[e.exchange];if(!o)throw new Error(`Exchange ${e.exchange} not found in CCXT Pro`);const r={sandbox:e.sandbox,apiKey:e.apiKey,secret:e.secret,password:e.password,enableRateLimit:!0};console.log(`ðŸ” [CCXTAccountManager] Creating CCXT Pro ${e.exchange} instance:`,{accountId:e.accountId,sandbox:r.sandbox,apiKey:r.apiKey?"SET":"NOT_SET",secret:r.secret?"SET":"NOT_SET",enableRateLimit:r.enableRateLimit});const l=new o(r),n=g(l,e.exchange,e.accountId);return await this.loadMarketsWithCache(n,e.exchange,e.sandbox,"spot"),c.pro={instance:n,lastAccess:s,marketsLoaded:!0},console.log(`âœ… [CCXTAccountManager] Cached new CCXT Pro instance for ${t}`),n}catch(o){return console.error(`âŒ [CCXTAccountManager] Failed to create CCXT Pro instance for ${t}:`,o),null}}invalidateAccount(e,a){if(a){const t=this.createAccountKey(e,a);this.accountsCache.delete(t),console.log(`ðŸ—‘ï¸ [CCXTAccountManager] Invalidated cache for account: ${t}`)}else Array.from(this.accountsCache.keys()).filter(c=>c.startsWith(`${e}:`)).forEach(c=>this.accountsCache.delete(c)),console.log(`ðŸ—‘ï¸ [CCXTAccountManager] Invalidated cache for all exchanges of account: ${e}`)}clearCache(){this.accountsCache.clear(),this.marketsCache={},console.log("ðŸ§¹ [CCXTAccountManager] Cleared entire cache")}cleanup(){const e=[];this.accountsCache.forEach((a,t)=>{const c=[];a.regular.forEach((s,o)=>{this.isInstanceValid(s)||c.push(o)}),c.forEach(s=>a.regular.delete(s)),a.pro&&!this.isInstanceValid(a.pro)&&(a.pro=void 0),a.regular.size===0&&!a.pro&&e.push(t)}),e.forEach(a=>this.accountsCache.delete(a)),e.length>0&&console.log(`ðŸ§½ [CCXTAccountManager] Cleaned up ${e.length} expired account caches`)}getAccountStats(){const e=[];return this.accountsCache.forEach((a,t)=>{const[c,s]=t.split(":"),o=Date.now(),r=[];a.regular.forEach((n,C)=>{r.push({marketType:C,lastAccess:n.lastAccess,age:o-n.lastAccess,marketsLoaded:n.marketsLoaded})});const l={accountId:c,exchange:s,regularInstances:r};a.pro&&(l.proInstance={lastAccess:a.pro.lastAccess,age:o-a.pro.lastAccess,marketsLoaded:a.pro.marketsLoaded}),e.push(l)}),{totalAccounts:this.accountsCache.size,totalRegularInstances:Array.from(this.accountsCache.values()).reduce((a,t)=>a+t.regular.size,0),totalProInstances:Array.from(this.accountsCache.values()).filter(a=>a.pro).length,accounts:e}}}const x=new w;setInterval(()=>{x.cleanup()},10*60*1e3);export{x as ccxtAccountManager};
